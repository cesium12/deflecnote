<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no">
  <title>DeflecNote</title>
  <script src="jquery.min.js"></script>
  <script src="test.js"></script>
  <style>
body {
  position: fixed;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background: black;
  margin: 0;
}

body > * {
  position: absolute;
}

#playfield {
  top: 15%;
  bottom: 15%;
}

.p1 {
  color: magenta;
  background-color: magenta;
}

.p2 {
  color: cyan;
  background-color: cyan;
}

.glowy {
  height: 10%;
  width: 100%;
  background-image: linear-gradient(to bottom, black, black);
}

.glowy.p1 {
  bottom: 10%;
}

.glowy.p2 {
  top: 10%;
}

.target {
  position: absolute;
  border-radius: 50%;
  border: 5px outset silver;
}

.target.p1 {
  box-shadow: 0 0 1em magenta, 0 0 1em magenta;
}

.target.p2 {
  box-shadow: 0 0 1em cyan, 0 0 1em cyan;
}

.target.highlight {
  border-color: goldenrod;
}

.target.clickable {
  cursor: pointer;
}

.score {
  background-color: black;
}

.score.p1 {
  right: 0;
}

.score.p2 {
  left: 0;
}
  </style>
</head>
<body>
  <section class="score p1"></section>
  <section class="glowy p2"></section>
  <section class="glowy p1"></section>
  <canvas id="background"></canvas>
  <section id="playfield"></section>
  <script>
"use strict";

function Target(base, link) {
  Object.assign(this, base);
  var self = this;

  if (link) {
    if (!this.is_reflect) {
      this.t += link.delay;
    }
    this.t_final += link.delay;
    this.duration = link.duration;
    this.duration_spd = link.duration_spd;
  }
  this.spawn_y = this.is_reflect ? 0 : 0.05;
  this.spawn_t = this.spawn_y * (this.t_final - this.t);
  this.duration = this.duration || 0;
  this.duration_spd = this.duration_spd || 1;
  this.parent = base;
  console.log(this);

  this.elt = $('<div>').addClass('target')
      .addClass(this.top ? 'p1' : 'p2')
      // TODO make sure to cover all needed events
      // TODO long-tap doesn't dtrt on mobile
      .mousedown(this.tap.bind(this))
      .mouseup(this.out.bind(this))
      .mouseout(this.out.bind(this))
      .css({
        height: 2 * this.RADIUS,
        width: 2 * this.RADIUS,
        margin: -(this.RADIUS + 5),
        opacity: 0
      })
      .appendTo('#playfield');
  this.color = this.elt.css('background-color');

  var simultaneous = $();
  $.each(alive, function(_, note) {
    $.each(note.targets, function(_, target) {
      if (target.t_final == self.t_final) {
        simultaneous = simultaneous.add(target.elt);
      }
    });
  });
  if (simultaneous.length > 0) {
    simultaneous.add(this.elt).addClass('highlight');
  }

  if (this.v_x == 0) {
    this.lastBounce = this.t;
  } else {
    var final = this.positionAt(this.t_final);
    this.lastBounce = Math.max(this.t, this.t_final -
        (final.v_x > 0 ? final.x : (final.x - 1)) / final.v_x);
  }
}
Target.prototype.RADIUS = 20;
Target.prototype.positionAt = function(now) {
  var tStart = this.t + this.spawn_t;
  var tEffective = Math.max(tStart, now);
  var yFinal = 1; // TODO insets
  var yProgress = this.spawn_y + (yFinal - this.spawn_y) *
      (tEffective - tStart) / (this.t_final - tStart);
  var y = this.top ? yProgress : (1 - yProgress);
  if (tEffective > this.t_final) {
    var final = this.positionAt(this.t_final);
    var x = final.x + final.v_x * (tEffective - this.t_final);
    var v_x = final.v_x;
  } else {
    var xProgress = ((this.x + this.v_x * (tEffective - this.t)) % 2 + 2) % 2;
    var x = 1 - Math.abs(xProgress - 1);
    var v_x = xProgress < 1 ? this.v_x : -this.v_x;
  }
  return {y: y, x: x, v_x: v_x};
};
Target.prototype.step = function(now) {
  // this function is black magic; don't worry about it too much
  if (now >= this.t_tap + this.duration) {
    this.end(now);
  }
  this.opacity = Math.min(1, Math.max(0, (now - this.t) / this.spawn_t));
  this.elt.css('opacity', this.opacity);

  var t_tap = 't_tap' in this ? this.t_tap : now;
  var t_out = 't_out' in this ? this.t_out : now;
  var position = this.positionAt(t_tap + now - t_out);
  var end = position;
  this.elt.css({
    top: 100 * position.y + '%',
    left: 100 * position.x + '%'
  }).toggleClass('clickable', this.top && Math.abs(position.y - 1) < 0.05);

  if (this.duration) {
    var tail = (t_out - t_tap - this.duration) * this.duration_spd +
        t_tap + now - t_out;
    end = this.positionAt(Math.min(now, Math.max(this.lastBounce, tail)));
    background.duration(this.color, position, end);
  }

  return Math.abs(0.5 - end.y) < 1;
};
Target.prototype.tap = function(evt) {
  if (!('t_tap' in this) && this.elt.hasClass('clickable')) {
    this.t_tap = performance.now() - origin;
    // TODO brighten the note
  }
  evt.preventDefault();
};
Target.prototype.out = function(evt) {
  this.end(performance.now() - origin);
  evt.preventDefault();
};
Target.prototype.end = function(now) {
  if ('t_tap' in this && !('t_out' in this)) {
    if (now < this.t_tap + this.duration) {
      this.t_out = now;
    } else {
      this.t_out = this.t_tap + this.duration;
      this.done = true;
      // TODO fade and hide / explode the note
      $('.score.p1').text(++points + ' / ' + SONG.Hard.note_count_p1);
    }
  }
};

function Note(data) {
  Object.assign(this, data);
  var self = this;

  this.targets = [new Target(this)];
  $.each(this.linked || [], function(_, link) {
    self.targets.push(new Target(self, link));
  });
}
Note.prototype.step = function(now) {
  var alive = false;
  this.targets = $.grep(this.targets, function(target) {
    alive = target.step(now) || alive;
    return !target.done;
  });
  if (this.targets.length > 1 && this.targets[0].opacity == 1) {
    background.link(this.targets[0].color, this.targets);
  }
  return alive;
};

function Background() {
  this.canvas = $('#background')[0];
  this.playfield = $('#playfield');
  this.ctx = this.canvas.getContext('2d');
  $(window).resize(this.resize.bind(this)).resize();
}
Background.prototype.resize = function() {
  this.canvas.height = $(window).height();
  this.canvas.width = $(window).width();
  this.ctx.shadowColor = 'white';
  this.ctx.lineCap = 'round';
};
Background.prototype.clear = function() {
  this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
};
Background.prototype.link = function(color, targets) {
  this.ctx.lineWidth = 5;
  this.ctx.strokeStyle = color;
  this.ctx.globalAlpha = 1;

  var offset = this.playfield.offset();
  var position = targets[0].elt.position();

  this.ctx.beginPath();
  this.ctx.moveTo(position.left + offset.left, position.top + offset.top);
  for (var i = 1; i < targets.length; ++i) {
    position = targets[i].elt.position();
    this.ctx.lineTo(position.left + offset.left, position.top + offset.top);
  }
  this.ctx.stroke();
};
Background.prototype.duration = function(color, start, end) {
  this.ctx.lineWidth = 2 * (Target.prototype.RADIUS + 5);
  this.ctx.strokeStyle = color;
  this.ctx.globalAlpha = 0.5;

  var offset = this.playfield.offset();
  var width = this.playfield.width();
  var height = this.playfield.height();

  this.ctx.beginPath();
  this.ctx.moveTo(start.x * width + offset.left, start.y * height + offset.top);
  this.ctx.lineTo(end.x * width + offset.left, end.y * height + offset.top);
  this.ctx.stroke();
};

var notes = SONG.Hard.notes.slice();
var origin;
var alive = [];
var points = 0;
var background;

function run(now) {
  now -= origin;
  background.clear();
  pulsate(now);
  while (notes.length && now >= notes[0].t) {
    alive.push(new Note(notes.shift()));
  }
  alive = $.grep(alive, function(note) {
    return note.step(now);
  });
  if (alive.length || notes.length) {
    requestAnimationFrame(run);
  } else {
    console.log('Done!'); // TODO what about when the music ends
  }
}

$(function() {
  $('#playfield').css({
    left: Target.prototype.RADIUS,
    right: Target.prototype.RADIUS
  });
  background = new Background();
  var songDelay = Math.max(0, -notes[0].t);
  // TODO load the music here
  origin = performance.now() + songDelay;
  setTimeout(function() {
    console.log('Start!'); // TODO start the music here
  }, songDelay);
  requestAnimationFrame(run);
});

function pulsate(now) {
  var bpm = SONG._metadata.bpm;
  for (var i = 1; i < bpm.length; ++i) {
    if (bpm[i][0] > now) {
      break;
    }
  }
  var phase = (now - bpm[i-1][0]) * bpm[i-1][1] / (60 * 1000);
  background.ctx.shadowBlur = 15 + 5 * Math.cos((phase - 4/8) * 2 * Math.PI);
  $('.glowy').css('background-image', 'linear-gradient(to bottom,' +
      'rgba(0, 0, 0, 1) 0%,' +
      'rgba(0, 0, 0, ' + (0.65 + 0.1 * Math.cos((phase - 4/8) * 2 * Math.PI)) + ') 10%,' +
      'rgba(0, 0, 0, ' + (0.60 + 0.1 * Math.cos((phase - 3/8) * 2 * Math.PI)) + ') 20%,' +
      'rgba(0, 0, 0, ' + (0.55 + 0.1 * Math.cos((phase - 2/8) * 2 * Math.PI)) + ') 30%,' +
      'rgba(0, 0, 0, ' + (0.50 + 0.1 * Math.cos((phase - 1/8) * 2 * Math.PI)) + ') 40%,' +
      'rgba(0, 0, 0, ' + (0.20 + 0.1 * Math.cos((phase - 4/8) * 2 * Math.PI)) + ') 50%,' +
      'rgba(0, 0, 0, ' + (0.50 + 0.1 * Math.cos((phase - 1/8) * 2 * Math.PI)) + ') 60%,' +
      'rgba(0, 0, 0, ' + (0.55 + 0.1 * Math.cos((phase - 2/8) * 2 * Math.PI)) + ') 70%,' +
      'rgba(0, 0, 0, ' + (0.60 + 0.1 * Math.cos((phase - 3/8) * 2 * Math.PI)) + ') 80%,' +
      'rgba(0, 0, 0, ' + (0.65 + 0.1 * Math.cos((phase - 4/8) * 2 * Math.PI)) + ') 90%,' +
      'rgba(0, 0, 0, 1) 100%)');
  $('.target').css('background-image', 'radial-gradient(circle,' +
      'rgba(0, 0, 0, ' + (0.10 + 0.05 * Math.cos((phase - 4/8) * 2 * Math.PI)) + ') 0%,' +
      'rgba(0, 0, 0, ' + (0.15 + 0.10 * Math.cos((phase - 1/8) * 2 * Math.PI)) + ') 40%,' +
      'rgba(0, 0, 0, ' + (0.20 + 0.10 * Math.cos((phase - 2/8) * 2 * Math.PI)) + ') 70%,' +
      'rgba(0, 0, 0, ' + (0.20 + 0.15 * Math.cos((phase - 3/8) * 2 * Math.PI)) + ') 90%,' +
      'rgba(0, 0, 0, ' + (0.25 + 0.15 * Math.cos((phase - 4/8) * 2 * Math.PI)) + ') 100%)');
}
  </script>
</body>
</html>
